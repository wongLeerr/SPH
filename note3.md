# nextTick
官方解释：将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。
我的理解：就是页面的DOM元素渲染完毕才会执行nextTick里面的回调函数。
# 由于Home组件中有两个子组件Floor，而这两个子组件中数据不相同，服务器返回两条数据分别对应这两个Floor组件，那么就应该在Home组件中书写一个组件，使用v-for动态生成2个组件（或者理解为服务器返回几条数据就生成几个组件），那也就意味着这个数据不能放到Floor组件中，而应该放到Floor组件的父组件Home组件当中。
# 组件间通信（面试概率极高）
# 切记：如果项目中某一个组件（或者可以拆分成一个组件的），在项目中的很多地方都需要使用，并且他们的结构非常类似，可以考虑将其注册为全局组件，即可在任意地方使用，全局组件放至components文件夹中
# 项目中某一模块开发通用套路
1.写静态页面
2.拆分为静态组件
3.书写发请求的API接口
4.vuex三连环
5.组件获取仓库数据，动态展示数据
# 一个细节问题：
在Search模块中的mounted钩子中派发action函数发起AJAX请求，注意不切换到Search模块是不会执行Search模块的mounted钩子的，AJAX请求也就不会发出去，数据也就不会有
# 关于组件间通信的常用手段
父->子：一般使用props
子->父：一般使用自定义事件
兄弟->兄弟：一般使用全局事件总线
# 项目中最有价值的几块儿内容
1.分页器
2.支付模块
3.登录注册模块
4.轮播图
5.日历
6.GIT
# 关于分页器
前置知识：
pageNo代表当前是第几页
pageSize代表每一页展示多少条数据
total代表整个分页器一共有多少条数据
continues连续页码数，常见的有5和7，就是...与...之间有几个页码，当前页码位于这5个页码或者7个页码的最中央
注意：
1.自定义分页器在开发的时候先传递假的数据进行调试，确保分页器功能完备以后再跟服务器扯上关系。
2.分页器分为上中下三部分去搞（上部以...结束，下部以...开头，两个...中间部分是中部）
关键点：
1.算出连续页面起始数字和结束数字
如当前页第11页
连续数字应该展示
9 10 11 12 13
2.v-for不仅可以遍历数组，也可以遍历数字，字符串，对象等
# 一个重要的细节
例如一个图片是一个路由跳转，而此图片位于路由的最底端（这意味着页面右侧的大滚动条也在最下方），这样点击图片进行路由跳转到了一个新的页面滚动条依然位于此页面的最底端，这是很不友好的。
知识点：此是Vue中的滚动行为模块，属于路由范畴，是new Router实例时的配置信息。
# 关于收到的数据是空的或者undefined的相关处理
在进行AJAX操作时，由于向服务器发请求需要时间，服务器响应数据同样需要时间，这样在数据还没有返回之前，该数组或者对象极有可能是空值，在使用.扒取内层数据时就会出现undefined的现象，而此undefined又有可能向内侧扒取数据，导致控制台警告，此时应该对于有可能出现undefined的地方进行处理，如undefined||(某种数据类型，空数组或者空对象)，虽然不解决此问题工程可以正常运行，但是将红色干掉是必要的。
# 并不是所有涉及到vuex的操作都需要三连环，有时候只需派发一个action函数（带了一些数据，让服务器保存），服务器只需告诉你是否他已收到你的数据，不需要返回你其他数据，因此也没有必要储存在仓库当中。
# async 和 await后面的函数都有返回值，返回值都是promise对象
# this.$store.dispach()函数的返回值是一个promise对象
# 浏览器存储
HTML5新增特性：（本地存储、会话存储）
何为HTML5?
HTML的第五次革命改革
HTML1993年出生
在路由跳转时，一般一些简单的数据通过query参数带过去
但在需要传递的信息比较复杂时通过会话存储的方式解决，正是利用会话存储的非持久化存储的特点，会话结束后数据就消失。
何为一次会话？
在单页面应用中可以认为打开浏览器进行一些操作然后关闭浏览器就是一次会话.
无论本地存储还是会话存储都只能存储字符串.
# UUID
UUID 是指Universally Unique Identifier，翻译为中文是通用唯一识别码，UUID 的目的是让分布式系统中的所有元素都能有唯一的识别信息。如此一来，每个人都可以创建不与其它人冲突的 UUID，就不需考虑数据库创建时的名称重复问题。
# 关于购物车很重要的一件事
明白:一个购物网站是面向大众的,不可能每个人选的物品都放到服务器数据库中的同一房间当中,这就意味着,必须将服务器数据库分割成若干个小房子,事实上每个小房子对应一个用户,用户的信息还有购物车数据等都应该属于自己的小房子,这才使得众多用户本质上毫无瓜葛.
万物的根源:在于选好了物品点击加入购物车的一瞬间,需要辨别你的身份,因为只有在知道你的身份以后才可以为你开辟小房间(新用户)或者为你打开房门(老用户),才可以进行自己购物信息的相关操作.
应该明白:使用游客身份登录你的id应该永恒不变(因为为你开辟了一个房间,你以后都应该在这个房间),不能说每次都要生成一个新的游客身份(开辟多个房间,各个房间没有任何关系).这不符合常理
使用uuid每次调用都会生成一个新的id,但我们只需要一个id,因此利用到本地存储机制
# 某仓库actions中有两个函数a和b，a可以调用b函数----(但要通过a函数上下文对象（context）中的dispatch函数调用)
# Promise.all方法
Promise.all([p1,p2,p3])
里面的p1,p2,p3均为promise对象，但凡有一个状态为失败，则整个结果就是失败的
# assets
assets文件夹存放全部组件共用的静态资源
# token(令牌)
登录的前提是注册，当用户注册成功后，后台数据库将存储用户信息（例如账户和密码）
登录成功以后，后台服务器为了区分你这个用户是谁，会下发给你一个token令牌（唯一标识符）
正常情况下，登录成功以后服务器会下发token，前台持久化存储token，这样就可以实现带着token找服务器要用户信息进行展示。
# vuex存储数据不是持久化的，即一刷新数据就没了
# action中不可以操作state，想要操作state，提交mutations方法，在mutation中操作state
# 如何判断用户是否处于登录状态
检查仓库中token是否有值，因为没有登陆token为空，登陆了token有值，退出登录清除token，token依旧为空。
# 获取交易页面的用户信息的前提必须是已经登录了
# 不要在生命周期钩子函数前面加上async
# 关于组件库
antD(vue react)但只针对PC端
antD-mobile(vue react)（移动端）
ElementUI(vue) 针对PC端
# 项目的配置文件发生变化，项目需要重启
# 二维码生成 qrcode
# 关于路由守卫
全局守卫（前置、后置）：在router文件中定义，操纵的是router实例对象，只要有路由的切换就可以检测到
路由独享守卫：在routes中定义，只负责某个确定的路由，想守护哪个路由就在哪个路由规则中定义。
组件内守卫：在组件中定义，用法跟钩子函数类似
# 图片懒加载插件
同样存在版本问题（vue2不能与最新版本的插件配合使用）
# modifiers修饰符
可以给自定义指令自定义修饰符如v-xiaozhu.peiqi
# vee-validate表单验证插件
2版本比3版本好用
# 路由懒加载
当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。
# map文件
项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码出现了错误，有了map文件就好像一个导航一样，准确的输出是哪一行出现了错误。
所以该文件如果项目中不需要可以去除。（通过配置项,打包时压根不生成map文件）
# xftp7 软件
往远程服务器上传输文件
# xshell软件
登录服务器
让项目上线的大致步骤：
购买服务器（阿里云、腾讯云）->设置安全组（让服务器的一些端口号打开）->利用xshell工具登录服务器->->->
# 服务器物理状态可以在腾讯云官网我的服务器进行控制（如关机服务器，重启服务器等等，但是要是服务器为我们服务，我们需要借助一些软件，像xshell、xftp）
# 问题
问题？我在服务器上创建了一些文件夹，其中一个文件下存放了我的项目文件dist，但为什么别人访问这个网站就可以自动找到这个dist文件夹？-------需要对nginx服务器进行一些配置
# 何为nginx（本质上就是一个服务器）
Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，可以实现用户访问一个服务器，而这个服务器需要向其他服务器索要数据（nginx就是实现这个功能的）。


# axios二次封装
发请求的方式:XMLHttpRequest fetch JQuery axios
为什么要进行二次封装axios？
为了实现请求拦截器、响应拦截器
何为请求拦截器？可以在发请求之前处理一些业务
何为响应拦截器？当服务器返回数据以后，可以处理一些业务逻辑
# src文件夹下需要新建一个api文件夹，用于存放axios的封装以及相应的请求
# api文件夹下的request文件中是对axios的封装，以后哪里发请求就导入此文件使用封装好的requests发请求
# api文件下的index文件是发请求的文件，将发请求的函数导出，哪里需要发请求，就导入此文件中的某个函数，直接调用函数就相当于发出请求了
# nprogress进度条
应该在请求拦截器和响应拦截器中使用
# vuex状态管理库
vuex是官方提供的插件.状态管理库,集中式管理项目中组件共用的数据
# 事件委派或称事件委托
基本思路就是把此元素可能还有其他元素包裹一层父元素，然后把本身要执行的事件放在父元素上面，相当于把事件委托出去了。
# 防抖与节流
正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿）
防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次
节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
# 实现三级联动路由跳转问题
为什么将三级联动中所有的a标签换成router-link后会出现卡顿现象？
理解router-link本身是一个组件，所有的一级菜单加二级菜单加三级菜单全部渲染成为组件非常消耗内存，因此出现卡顿现象，因此这里建议使用编程式路由导航。
思考？为什么给里面的每一个a标签都加一个点击事件这种方法的性能并不好，因为相当于绑定了1000多个事件，有1000多个回调函数，依旧不够完美。
最好的实现思路：编程式路由导航+事件委派（点击事件加到共有的父元素身上） --但又存在若干个问题？
1.如何判断我点击的是a标签而不是h2标题或者其他标签呢？（因为只有是a标签时才要跳转，现在使用事件委派变成了点击这个父元素中的任意便签都会跳转）
解法：给a标签添加自定义属性data-categoryName(vue要求必须是data-开头，且vue自动将data-去除),同时利用点击事件对象event，以区分此是a标签，不是其他的标签，节点身上有dataset属性，即event.target.dataset可以获取到节点的自定义属性与属性值
****(一个小细节：我们添加的自定义属性data-categoryName在浏览器中已经给我们解析成了categoryname(已经帮我们去除掉了data-))
2.如何确定具体是几级的a标签，即如何区分具体是哪个标签?
解法：同样的方法，可以继续追加自定义属性，不同的分类就加上不同的自定义属性
# 过渡动画效果
过渡动画:前提是该组件中务必要有v-if或者v-show指令才可以进行过渡动画,外层用transition标签包裹,且注意,如果此transition标签没有name属性,定义动画时就用v-enter...定义,如果有name属性(比如叫sort),那就用sort-enter等等
# 利用App组件最先挂载,并且只会挂载一次的特性
我们可以把三级联动请求服务器的操作(其实就是一个dispatch函数)放至App组件的挂载函数中,这样一旦App组件挂载完毕,仓库中就有了对应的数据,哪里用到三级联动就去仓库中取数据就行,这解决了多次向服务器发出请求,多次更新仓库,但是这些数据始终是重复的问题.
# mock技术
mock本身有模拟的意思，就是前端模拟数据（模拟从服务器返回数据）
需要用到插件mockjs
使用mockjs生成数据不会打扰到后端服务器，并且浏览器会自动拦截ajax请求，也就是纯纯前端自己在玩耍。
使用步骤：
1.在项目src文件下创建mock文件夹
2.准备JSON数据（mock文件夹下创建相应的JSON文件，里面存放JSON数据）---记得格式化一下，JSON格式不对就乱套了。
3.把mock数据需要的图片放置到public文件下的images文件夹中，【public文件夹在打包时会把相应资源原封不动的放到dist文件夹下】
4.创建mockServe文件夹，使用mockjs插件，开始mock数据（虚拟数据），通过mockjs模块实现
5.mockServe.js文件在入口文件引入（否则怎么执行呢？）
# webpack默认对外暴露：图片、JSON数据，因此JSON文件无需将JSON数据暴露外界就可以引入

